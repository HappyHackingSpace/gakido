{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gakido","text":"<p>High-performance CPython HTTP client with browser impersonation, HTTP/2, optional native fast-path, async support, and WebSockets.</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from gakido import Client\n\nwith Client(impersonate=\"chrome_120\") as c:\n    r = c.get(\"https://example.com\")\n    print(r.status_code, r.text[:200])\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Browser profiles (Chrome/Firefox/Safari/Edge/Tor aliases)</li> <li>JA3/Akamai-like overrides via <code>tls_configuration_options</code></li> <li>HTTP/1.1 and HTTP/2 (ALPN) plus optional native HTTP fast-path</li> <li>Async client</li> <li>Multipart uploads</li> <li>Minimal WebSocket client</li> </ul>"},{"location":"api/","title":"API Reference (essentials)","text":""},{"location":"api/#gakidoclient","title":"gakido.Client","text":"<ul> <li><code>Client(impersonate=\"chrome_120\", ja3=None, tls_configuration_options=None, proxies=None, timeout=10.0, verify=True, use_native=True, force_http1=True, auto_decompress=True)</code></li> <li>Methods: <code>get</code>, <code>post</code>, <code>request</code>, <code>close</code>, context manager.</li> <li><code>files</code> supported on <code>post</code>/<code>request</code> for multipart.</li> </ul>"},{"location":"api/#gakidoaioasyncclient","title":"gakido.aio.AsyncClient","text":"<ul> <li><code>AsyncClient(impersonate=\"chrome_120\", timeout=10.0, verify=True, proxy_pool=None, ja3=None, tls_configuration_options=None, force_http1=True, http3=False, http3_fallback=True, auto_decompress=True)</code></li> <li>Async context manager; methods <code>get</code>, <code>post</code>, <code>request</code>, <code>close</code>.</li> </ul>"},{"location":"api/#compression-parameters","title":"Compression Parameters","text":"Parameter Type Default Description <code>auto_decompress</code> <code>bool</code> <code>True</code> Automatically decompress gzip/deflate/br responses <p>When <code>auto_decompress=True</code>: - Uses the profile's <code>Accept-Encoding</code> header (e.g., <code>gzip, deflate, br</code> for Chrome) - Automatically decompresses response bodies based on <code>Content-Encoding</code> - Supports gzip, deflate, and brotli (br) encodings</p> <p>When <code>auto_decompress=False</code>: - Sends <code>Accept-Encoding: identity</code> (no compression) - Returns raw, uncompressed response bodies</p>"},{"location":"api/#http3-parameters","title":"HTTP/3 Parameters","text":"Parameter Type Default Description <code>http3</code> <code>bool</code> <code>False</code> Enable HTTP/3 (QUIC) for compatible targets <code>http3_fallback</code> <code>bool</code> <code>True</code> Fall back to HTTP/1.1 or HTTP/2 if HTTP/3 fails <code>force_http3</code> <code>bool</code> <code>None</code> Per-request override (in <code>request()</code> method)"},{"location":"api/#gakidois_http3_available","title":"gakido.is_http3_available","text":"<ul> <li><code>is_http3_available() -&gt; bool</code></li> <li>Returns <code>True</code> if aioquic is installed and HTTP/3 support is available.</li> </ul>"},{"location":"api/#profiles","title":"Profiles","text":"<ul> <li><code>impersonate</code> accepts keys from <code>gakido.impersonation.PROFILES</code> (Chrome/Firefox/Safari/Edge/Tor aliases).</li> <li>Profiles include HTTP/3 settings (<code>http3.max_stream_data</code>, <code>http3.max_data</code>, <code>http3.idle_timeout</code>).</li> </ul>"},{"location":"api/#tls-overrides","title":"TLS overrides","text":"<ul> <li><code>ja3</code> dict: override ciphers/alpn/curves/sig_algs.</li> <li><code>tls_configuration_options</code>: accepts <code>ja3_str</code>, <code>akamai_str</code>, <code>extra_fp</code> (<code>ExtraFingerprints</code>).</li> </ul>"},{"location":"api/#websocket","title":"WebSocket","text":"<ul> <li><code>gakido.websocket.WebSocket.connect(host, port, resource, headers, tls, timeout)</code></li> <li>Methods: <code>send_text</code>, <code>send_bytes</code>, <code>recv</code>, <code>close</code>.</li> </ul>"},{"location":"api/#installation-extras","title":"Installation Extras","text":"<pre><code>pip install gakido          # Core package\npip install gakido[h3]      # With HTTP/3 (QUIC) support\npip install gakido[dev]     # Development dependencies\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<ul> <li>Run <code>pre-commit run --all-files</code> before pushing.</li> <li>Build docs: <code>make docs</code> (or <code>make docs-serve</code>).</li> <li>Tests: <code>make test</code>.</li> <li>Lint/format: <code>make lint</code> (ruff + ty).</li> <li>Native extension: built from <code>gakido/core.c</code> as <code>gakido_core</code> via <code>uv pip install -e .</code>.</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":""},{"location":"user-guide/#sync-client","title":"Sync client","text":"<pre><code>from gakido import Client\n\nwith Client(impersonate=\"chrome_120\") as c:\n    r = c.get(\"https://httpbin.org/get\", headers={\"Accept-Encoding\": \"identity\"})\n    print(r.status_code, r.json())\n</code></pre>"},{"location":"user-guide/#post-multipart-upload","title":"POST / multipart upload","text":"<pre><code>files = {\"file\": (\"test.txt\", b\"hello\", \"text/plain\")}\ndata = {\"foo\": \"bar\"}\nwith Client() as c:\n    r = c.post(\"https://httpbin.org/post\", data=data, files=files)\n    print(r.json())\n</code></pre>"},{"location":"user-guide/#async-client","title":"Async client","text":"<pre><code>import asyncio\nfrom gakido.aio import AsyncClient\n\nasync def main():\n    async with AsyncClient(impersonate=\"chrome_120\") as c:\n        r = await c.get(\"https://httpbin.org/get\")\n        print(r.status_code)\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/#profiles-impersonation","title":"Profiles &amp; impersonation","text":"<pre><code>from gakido import Client\n\nc = Client(impersonate=\"firefox_133\")\nr = c.get(\"https://tls.browserleaks.com/json\")\nprint(r.json().get(\"ja3_hash\"))\n</code></pre>"},{"location":"user-guide/#tls-overrides-ja3akamai-style","title":"TLS overrides (JA3/Akamai style)","text":"<pre><code>from gakido import Client, ExtraFingerprints\n\nja3_str = \"771,4866-4867-4865-49196,0-11-10,29,0\"\nextra_fp = ExtraFingerprints(alpn=[\"http/1.1\"])\n\nwith Client(\n    tls_configuration_options={\n        \"ja3_str\": ja3_str,\n        \"extra_fp\": extra_fp,\n    },\n    ja3={\"alpn\": [\"http/1.1\"]},\n) as c:\n    r = c.get(\"https://tls.browserleaks.com/json\", headers={\"Accept-Encoding\": \"identity\"})\n    print(r.json())\n</code></pre>"},{"location":"user-guide/#websocket","title":"WebSocket","text":"<pre><code>from gakido.websocket import WebSocket\n\nws = WebSocket.connect(\"echo.websocket.events\", 443, \"/\", headers=[], tls=True)\nws.send_text(\"hello\")\nopcode, payload = ws.recv()\nprint(payload.decode())\nws.close()\n</code></pre>"},{"location":"user-guide/#compression","title":"Compression","text":"<p>Gakido automatically handles response compression using profile-based content negotiation.</p>"},{"location":"user-guide/#default-behavior-auto_decompresstrue","title":"Default Behavior (auto_decompress=True)","text":"<pre><code>from gakido import Client\n\n# Uses profile's Accept-Encoding: \"gzip, deflate, br\"\n# Automatically decompresses responses\nwith Client(impersonate=\"chrome_120\") as c:\n    r = c.get(\"https://httpbin.org/gzip\")\n    print(r.json())  # Already decompressed\n</code></pre>"},{"location":"user-guide/#disable-compression","title":"Disable Compression","text":"<pre><code>from gakido import Client\n\n# Sends Accept-Encoding: identity\n# Returns raw, uncompressed responses\nwith Client(auto_decompress=False) as c:\n    r = c.get(\"https://example.com\")\n    print(r.content)  # Raw bytes\n</code></pre>"},{"location":"user-guide/#custom-accept-encoding","title":"Custom Accept-Encoding","text":"<pre><code>from gakido import Client\n\n# Override Accept-Encoding per request\nwith Client() as c:\n    r = c.get(\"https://example.com\", headers={\"Accept-Encoding\": \"gzip\"})\n</code></pre>"},{"location":"user-guide/#supported-encodings","title":"Supported Encodings","text":"<ul> <li>gzip - GNU zip compression</li> <li>deflate - zlib/deflate compression</li> <li>br - Brotli compression (included via <code>brotli</code> package)</li> </ul>"},{"location":"user-guide/#http3-quic","title":"HTTP/3 (QUIC)","text":"<p>HTTP/3 uses QUIC as the transport layer, providing improved performance for Cloudflare and CDN targets through 0-RTT connection establishment and multiplexed streams.</p>"},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip install gakido[h3]\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom gakido import AsyncClient, is_http3_available\n\nasync def main():\n    # Check if HTTP/3 is available\n    if not is_http3_available():\n        print(\"Install HTTP/3 support: pip install gakido[h3]\")\n        return\n\n    async with AsyncClient(\n        impersonate=\"chrome_120\",\n        http3=True,           # Enable HTTP/3\n        http3_fallback=True,  # Fall back to H1/H2 if H3 fails\n        force_http1=False,    # Allow H2 as fallback\n    ) as client:\n        response = await client.get(\"https://cloudflare.com/cdn-cgi/trace\")\n        print(f\"HTTP/{response.http_version}: {response.status_code}\")\n        print(response.text)\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/#force-http3-for-specific-requests","title":"Force HTTP/3 for Specific Requests","text":"<pre><code>async with AsyncClient(http3=True) as client:\n    # Use client default (HTTP/3 with fallback)\n    r1 = await client.get(\"https://example.com\")\n\n    # Force HTTP/3 for this specific request (no fallback)\n    r2 = await client.request(\"GET\", \"https://cloudflare.com\", force_http3=True)\n</code></pre>"},{"location":"user-guide/#http3-benefits","title":"HTTP/3 Benefits","text":"<ul> <li>0-RTT Connection: Faster initial requests with QUIC's zero round-trip handshake</li> <li>No Head-of-Line Blocking: Multiplexed streams don't block each other</li> <li>Connection Migration: Survives network changes (WiFi to cellular)</li> <li>Built-in Encryption: TLS 1.3 integrated into the protocol</li> </ul>"}]}